;;; ============================================================
;;;
;;; More Apple II Symbols
;;;
;;; ============================================================

;;; Zero Page

COUT_HOOK       := $36

;;; Other Pages

IN              := $200


;;; ============================================================
;;; Vectors
;;; ============================================================

IRQLOC          := $3FE


;;; ============================================================
;;; Monitor ROM
;;; ============================================================

;;; Monitor
IDBYTELASER128  := $FB1E        ; $AC = Laser 128
INIT            := $FB2F        ; Initialize text screen.
SETPWRC         := $FB6F        ; Create power-up byte.
VERSION         := $FBB3        ; Monitor ROM ID byte. $06 = IIe or later
ZIDBYTE2        := $FBBF        ; * IIc ROM version ($05 = IIc+)
ZIDBYTE         := $FBC0        ; * $EA = IIe, $E0 = IIe enh/IIgs, $00 = IIc/IIc+
BELL1           := $FBDD        ; Generate tone.
VTAB            := $FC22        ; Vertical tab. Uses value at CV.
VTABZ           := $FC24        ; Vertical tab (alternate entry). Uses A.
HOME            := $FC58        ; Home cursor and clear to end of page.
CROUT           := $FD8E        ; Issue a carriage return.
PRBYTE          := $FDDA        ; Print a hexadecimal byte.
COUT            := $FDED        ; Output a character.
IDROUTINE       := $FE1F        ; RTS ($60) on pre-IIgs, clears carry on IIgs
MOVE            := $FE2C        ; Original Monitor Move routine.
SETKBD          := $FE89        ; Reset input to keyboard.
SETVID          := $FE93        ; Reset output to screen.
MONZ            := $FF69        ; Standard Monitor entry point.

F8VERSION       := $06


;;; ============================================================
;;; Applesoft Basic ROM
;;; ============================================================

;;; Zero Page

LINNUM          := $50          ; Line number, unsigned word
ERRFLG          := $D8
CHRGET          := $B1          ; Routine called by ROM
TXTPTR          := $B8
FAC             := $9D
SHIFT_SIGN_EXT  := $A4          ; Zero before using FP ops

;;; Entry Points
GIVAYF          := $E2F2        ; FAC from signed integer in (Y,A)
CONINT          := $E6FB        ; FAC = X as unsigned byte
GETADR          := $E752        ; FAC to unsigned integer in LINNUM
FADDH           := $E7A0        ; Add 0.5 to FAC
FSUB            := $E7A7        ; FAC = (Y,A) - FAC
FSUBT           := $E7AA        ; FAC = ARG - FAC
FADD            := $E7BE        ; FAC = (Y,A) + FAC
FADDT           := $E7C1        ; FAC = ARG + FAC
ZERO_FAC        := $E84E        ; FAC = 0
LOG             := $E941        ; FAC = LOG(FAC)
FMULT           := $E97F        ; FAC = (Y,A) * FAC
FMULTT          := $E982        ; FAC = ARG * FAC
DIV10           := $EA55        ; FAC = FAC / 10
FDIV            := $EA66        ; FAC = (Y,A) / FAC
FDIVT           := $EA69        ; FAC = ARG / FAC
LOAD_ARG        := $EAE3        ; ARG = (Y,A)
MOVFM           := $EAF9        ; FAC = (Y,A)
LOAD_FAC        := $EAF9        ; FAC = (Y,A)
MOVMF           := $EB2B        ; (Y,X) = FAC
ROUND           := $EB2B        ; Round FAC, store at (Y,X)
ARG_TO_FAC      := $EB53        ; ARG = FAC
FAC_TO_ARG_R    := $EB63        ; FAC = ARG, rounded
SGN             := $EB90        ; FAC = SGN(FAC)
FLOAT           := $EB93        ; FAC = A as signed byte
FLOAT1          := $EB9B        ; FAC from unsigned integer in FAC+1,2 eX
FLOAT2          := $EBA0        ; FAC from unsigned integer in FAC+1,2 eX, carry set = positive
ABS             := $EBAF        ; FAC = ABS(FAC)
FCOMP           := $EBB2        ; FAC <=> (Y,A), result in A
QINT            := $EBF2        ; FAC to signed integer in FAC+1...FAC+4 (e < 32)
INT             := $EC23        ; FAC = INT(FAC)
FIN             := $EC4A        ; Parse TEXTPTR to FAC (first char in A, C set if digit)
FOUT            := $ED34        ; FAC as string to FBUFFR (trashes FAC)
SQR             := $EE8D        ; FAC = SQR(FAC)
NEGOP           := $EED0        ; FAC = -FAC
EXP             := $EF09        ; FAC = EXP(FAC)
RND             := $EFAE        ; FAC = RND(FAC)
COS             := $EFEA        ; FAC = COS(FAC)
SIN             := $EFF1        ; FAC = SIN(FAC)
TAN             := $F03A        ; FAC = SIN(FAC)
ATN             := $F09E        ; FAC = ATN(FAC)

;;; Constants
CON_ONE         := $E913        ; 1
CON_SQR_HALF    := $E92D        ; SQR(1/2)
CON_SQR_TWO     := $E932        ; SQR(2)
CON_NEG_HALF    := $E937        ; -1/2
CON_LOG_TWO     := $E93C        ; LOG(2)
CON_TEN         := $E950        ; 10
CON_BILLION     := $ED14        ; 1E9
CON_HALF        := $EE64        ; 1/2
CON_LOG2_E      := $EEDB        ; Log(E) base 2 ????
CON_HALF_PI     := $F063        ; pi/2
CON_TWO_PI      := $F06B        ; pi/*2
CON_QUARTER     := $F070        ; 1/4

;;; Other
FBUFFR          := $100


;;; ============================================================
;;; Softswitches
;;; ============================================================

RAMRDOFF        := $C002        ; Read from main 48K RAM
RAMRDON         := $C003        ; Read from alternate 48K RAM
RAMWRTOFF       := $C004        ; Write to main 48K RAM
RAMWRTON        := $C005        ; Write to alternate 48K RAM
ALTZPOFF        := $C008        ; Use main zero page/stack
ALTZPON         := $C009        ; Use alternate zero page/stack

CLR80VID        := $C00C        ; Disable 80-column hardware
SET80VID        := $C00D        ; Enable 80-column hardware
RDALTZP         := $C016        ; Bit 7 = 1 if slot zp enabled
RD80STORE       := $C018        ; Bit 7 = 1 if 80-column store
RDPAGE2         := $C01C

KEYMODREG       := $C025        ; IIgs - keyboard modifiers
        ;; bit 7= Open Apple key active
        ;; bit 6= Closed Apple key active
        ;; bit 5= Updated modifier latch without keypress
        ;; bit 4= Keypad key active
        ;; bit 3= Repeat active
        ;; bit 2= Caps lock active
        ;; bit 1= Control key active
        ;; bit 0= Shift key active

NEWVIDEO        := $C029        ; IIgs - new video modes
        ;; Bit 7 = 1 = Enable Super-Hi-Res
        ;; Bit 6 = 1 = Linearize SHR
        ;; Bit 5 = 0 = Color DHR, 1 = B/W DHR
        ;; Bits 4-0 must be 0

SPKR            := $C030
SHADOW          := $C035        ; IIgs - inhibit shadowing

;;; Video mode
PAGE2OFF        := $C054
PAGE2ON         := $C055
HIRESON         := $C056
HIRESOFF        := $C057

AN3_OFF         := $C05E
AN3_ON          := $C05F

RAMWORKS_BANK   := $C073

ROMIN2          := $C082


;;; Le Chat Mauve Eve registers
HR1_OFF         := $C0B2
HR1_ON          := $C0B3
HR2_OFF         := $C0B4
HR2_ON          := $C0B5
HR3_OFF         := $C0B6
HR3_ON          := $C0B7
TEXT16_OFF      := $C0B8
TEXT16_ON       := $C0B9

;;; ============================================================
;;; Aux Memory / Extended 80 Column Card
;;; ============================================================

;;; Routines
SLOT3ENTRY      := $C300
AUXMOVE         := $C311        ; carry set main>aux, carry clear aux>main
XFER            := $C314

;;; Zero Page Locations
STARTLO         := $3C
STARTHI         := $3D
ENDLO           := $3E
ENDHI           := $3F
DESTINATIONLO   := $42
DESTINATIONHI   := $43

;;; Other Locations
XFERSTARTLO     := $03ED
XFERSTARTHI     := $03EE


;;; ============================================================
;;; Disk II / IWM I/O locations
;;; ============================================================

;;; $C0nX, n = slot + 8 -- c/o http://archive.li/ewHUL
PHASE0  := $C080                ; Stepper motor phase 0
PHASE1  := $C082                ; Stepper motor phase 1
PHASE2  := $C084                ; Stepper motor phase 2
PHASE3  := $C086                ; Stepper motor phase 3
DISABLE := $C088                ; Turn disk drive off
ENABLE  := $C089                ; Turn disk drive on
SELECT  := $C08A                ; Select drive 1 or 2
SELECT1 := $C08A                ; Select drive 1
SELECT2 := $C08B                ; Select drive 2
XMIT    := $C08C                ; Get/set bits to/from disk
TESTWP  := $C08D                ; Test WP mode (then WPRES has result)
DATA    := $C08D                ; Write data to buffer (then XMIT to send)
WPRES   := $C08E                ; WP mode test result
RDMODE  := $C08E                ; Turn off write mode
WRMODE  := $C08F                ; Turn on write mode


;;; ============================================================
;;; Mouse Peripheral Card
;;; ============================================================

;;; Firmware Routines

SETMOUSE        = $12
SERVEMOUSE      = $13
READMOUSE       = $14
CLEARMOUSE      = $15
POSMOUSE        = $16
CLAMPMOUSE      = $17
HOMEMOUSE       = $18
INITMOUSE       = $19

;;; Constants

CLAMP_X         = 0
CLAMP_Y         = 1

MOUSE_MODE_OFF  = $00
MOUSE_MODE_TRANS= $01
MOUSE_MODE_INT  = $03
MOUSE_MODE_BTN  = $05

;;; RAM Locations

CLAMP_MIN_LO    := $478
CLAMP_MIN_HI    := $578
CLAMP_MAX_LO    := $4F8
CLAMP_MAX_HI    := $5F8

;;; RAM Locations
;;; (Add $Cn where n is slot to these)

MOUSE_X_LO      := $03B8
MOUSE_X_HI      := $04B8
MOUSE_Y_LO      := $0438
MOUSE_Y_HI      := $0538
MOUSE_STATUS    := $06B8
MOUSE_MODE      := $0738


;;; ============================================================
;;; ASCII Character Constants
;;; ============================================================

CHAR_MASK       = $7F
CASE_MASK       = $DF

CHAR_CTRL_C     = $03
CHAR_LEFT       = $08
CHAR_TAB        = $09
CHAR_DOWN       = $0A
CHAR_UP         = $0B
CHAR_RETURN     = $0D
CHAR_CTRL_O     = $0F
CHAR_RIGHT      = $15
CHAR_ESCAPE     = $1B
CHAR_DELETE     = $7F
